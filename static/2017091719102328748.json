{"description":"temp","public":true,"data":"var tracer = new WeightedUndirectedGraphTracer();\r\n\tvar tracerS = new Array1DTracer();\r\n\tvar logger = new LogTracer();\r\n\ttracer.attach(logger);\r\n","code":"\r\n\r\n\tvar G = [];\r\n\tfor(var i = 0; i < 5; i++) {\r\n\t\tG[i] = [];\r\n\t\tfor(var j = 0; j < 5; j++) {\r\n\t\t\tif(j == i) G[i].push(null);\r\n\t\t\telse G[i][j] = (Math.round(Math.random() * 5));\r\n\t\t}\r\n\t}\r\n\t//var G = WeightedUndirectedGraph.random(5, 1, 1, 9);\r\n\ttracer._setData(G);\r\n\tvar MAX_VALUE = Infinity;\r\n\tvar S = []; // S[end] returns the distance from start node to end node\r\n\tfor (var i = 0; i < G.length; i++) S[i] = MAX_VALUE;\r\n\ttracerS._setData(S);\r\n\t\r\n\tfunction Dijkstra(start, end) {\r\n\t\tvar minIndex, minDistance;\r\n\t\tvar D = []; // D[i] indicates whether the i-th node is discovered or not\r\n\t\tfor (var i = 0; i < G.length; i++) D.push(false);\r\n\t\tS[start] = 0; // Starting node is at distance 0 from itself\r\n\t\ttracerS._notify(start, S[start])._wait()._denotify(start);\r\n\t\ttracerS._select(start);\r\n\t\tvar k = G.length;\r\n\t\twhile (k--) {\r\n\t\t\t// Finding a node with the shortest distance from S[minIndex]\r\n\t\t\tminDistance = MAX_VALUE;\r\n\t\t\tfor (i = 0; i < G.length; i++) {\r\n\t\t\t\tif (S[i] < minDistance && !D[i]) {\r\n\t\t\t\t\tminDistance = S[i];\r\n\t\t\t\t\tminIndex = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (minDistance === MAX_VALUE) break; // If there is no edge from current node, jump out of loop\r\n\t\t\tD[minIndex] = true;\r\n\t\t\ttracerS._select(minIndex);\r\n\t\t\ttracer._visit(minIndex)._wait();\r\n\t\t\t// For every unvisited neighbour of current node, we check\r\n\t\t\t// whether the path to it is shorter if going over the current node\r\n\t\t\tfor (i = 0; i < G.length; i++) {\r\n\t\t\t\tif (G[minIndex][i] && S[i] > S[minIndex] + G[minIndex][i]) {\r\n\t\t\t\t\tS[i] = S[minIndex] + G[minIndex][i];\r\n\t\t\t\t\ttracerS._notify(i, S[i]);\r\n\t\t\t\t\ttracer._visit(i, minIndex, S[i])._wait();\r\n\t\t\t\t\ttracerS._denotify(i);\r\n\t\t\t\t\ttracer._leave(i, minIndex)._wait();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttracer._leave(minIndex)._wait();\r\n\t\t}\r\n\t\tif (S[end] === MAX_VALUE) {\r\n\t\t\tlogger._print('there is no path from ' + start + ' to ' + end);\r\n\t\t} else {\r\n\t\t\tlogger._print('the shortest path from ' + start + ' to ' + end + ' is ' + S[end]);\r\n\t\t}\r\n\t}\r\n\r\n\tvar s = Math.round(Math.random() * (G.length - 1)); // s = start node\r\n\tvar e; // e = end node\r\n\tdo {\r\n\t\te = Math.round(Math.random() * (G.length - 1));\r\n\t} while (s === e);\r\n\tlogger._print('finding the shortest path from ' + s + ' to ' + e)._wait();\r\n\tDijkstra(s, e);","language":"javascript","author":"Cardinal"}